
### **Моделі**

```python
# models/__init__.py
from .user import User
from .resource import Resource
from .booking import Booking
```

```python
# models/user.py
from sqlalchemy import Column, Integer, String, DateTime
from sqlalchemy.orm import relationship
from datetime import datetime
from app.database import Base

class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    email = Column(String, unique=True, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    bookings = relationship("Booking", back_populates="user")
```

```python
# models/resource.py
from sqlalchemy import Column, Integer, String
from sqlalchemy.orm import relationship
from app.database import Base

class Resource(Base):
    __tablename__ = 'resources'

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    description = Column(String, nullable=True)

    bookings = relationship("Booking", back_populates="resource")
```

```python
# models/booking.py
from sqlalchemy import Column, Integer, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from datetime import datetime
from app.database import Base

class Booking(Base):
    __tablename__ = 'bookings'

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    resource_id = Column(Integer, ForeignKey("resources.id"), nullable=False)
    start_time = Column(DateTime, nullable=False)
    end_time = Column(DateTime, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    user = relationship("User", back_populates="bookings")
    resource = relationship("Resource", back_populates="bookings")
```

---

### **Налаштування бази даних**

```python
# app/database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

DATABASE_URL = "sqlite:///./test.db"  # Замість SQLite можете використовувати PostgreSQL/MySQL

engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()
```



# m2m


Ось як можна змінити систему, щоб додати M2M зв’язок між користувачами та ресурсами. Це підходить для сценарію, коли **ресурс може бути одночасно заброньований кількома користувачами**, наприклад, групове бронювання.

---

### **Зміни в моделях**

1. **Додати асоціативну таблицю для M2M:**

```python
# models/associations.py
from sqlalchemy import Table, Column, Integer, ForeignKey
from app.database import Base

resource_user = Table(
    "resource_user",
    Base.metadata,
    Column("user_id", Integer, ForeignKey("users.id"), primary_key=True),
    Column("resource_id", Integer, ForeignKey("resources.id"), primary_key=True),
)
```

2. **Оновити модель `User`:**

```python
# models/user.py
from sqlalchemy import Column, Integer, String, DateTime
from sqlalchemy.orm import relationship
from datetime import datetime
from app.database import Base
from .associations import resource_user

class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    email = Column(String, unique=True, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    # Зв'язок з ресурсами через асоціативну таблицю
    resources = relationship("Resource", secondary=resource_user, back_populates="users")
```

3. **Оновити модель `Resource`:**

```python
# models/resource.py
from sqlalchemy import Column, Integer, String
from sqlalchemy.orm import relationship
from app.database import Base
from .associations import resource_user

class Resource(Base):
    __tablename__ = 'resources'

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    description = Column(String, nullable=True)

    # Зв'язок з користувачами через асоціативну таблицю
    users = relationship("User", secondary=resource_user, back_populates="resources")
```


---

### **Зміни у міграціях**

1. **Створення асоціативної таблиці:** Виконайте команду:

```bash
alembic revision --autogenerate -m "Add resource_user M2M table"
```

2. У файлі міграції додайте наступний код:

```python
def upgrade():
    op.create_table(
        'resource_user',
        sa.Column('user_id', sa.Integer(), nullable=False),
        sa.Column('resource_id', sa.Integer(), nullable=False),
        sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(['resource_id'], ['resources.id'], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint('user_id', 'resource_id')
    )

def downgrade():
    op.drop_table('resource_user')
```

3. Застосуйте міграції:

```bash
alembic upgrade head
```

---

### **Приклад використання M2M**

1. **Додавання користувача до ресурсу:**

```python
add_user_to_resource(db, user_id=1, resource_id=2)
```

2. **Отримання ресурсів для користувача:**

```python
user = db.query(User).filter(User.id == 1).first()
for resource in user.resources:
    print(resource.name)
```

3. **Отримання користувачів для ресурсу:**

```python
resource = db.query(Resource).filter(Resource.id == 2).first()
for user in resource.users:
    print(user.name)
```

---


# Валідації


### **Валідація на рівні моделей**

#### **Приклад: Валідація часу бронювання**

Мета: Переконатися, що час початку бронювання (`start_time`) завжди передує часу закінчення (`end_time`).

```python
# models/booking.py
from sqlalchemy import Column, Integer, ForeignKey, DateTime
from sqlalchemy.orm import relationship, validates
from datetime import datetime
from app.database import Base

class Booking(Base):
    __tablename__ = 'bookings'

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    resource_id = Column(Integer, ForeignKey("resources.id"), nullable=False)
    start_time = Column(DateTime, nullable=False)
    end_time = Column(DateTime, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    user = relationship("User", back_populates="bookings")
    resource = relationship("Resource", back_populates="bookings")

    @validates('start_time', 'end_time')
    def validate_time(self, key, value):
        if key == 'end_time' and self.start_time and value <= self.start_time:
            raise ValueError("End time must be after start time")
        return value
```

- Використано декоратор `@validates`, щоб перевіряти поля `start_time` і `end_time`.
- Якщо `end_time` не пізніше за `start_time`, піднімається виняток.

---

### **Чому важлива багаторівнева валідація?**

1. **Моделі (`@validates`)**:
    
    - Контроль цілісності даних на рівні SQLAlchemy.
    - Виконуються автоматично при створенні/оновленні записів.
2. **Сервіси**:
    
    - Логіка, яка враховує контекст (наприклад, конфлікти бронювань).
3. **Схеми (Pydantic/Marshmallow)**:
    
    - Забезпечують валідацію ще до взаємодії з базою даних.

Це забезпечує надійність і запобігає помилкам на різних рівнях.


# Колбек

### **Приклад реалізації колбеків у SQLAlchemy**

Колбеки (`events`) у SQLAlchemy використовуються для виконання дій до або після певних подій, таких як створення, оновлення чи видалення об'єктів. Це дозволяє автоматизувати додаткову логіку, наприклад, ведення журналу змін чи автоматичне заповнення полів.

---

### **1. Колбек для автоматичного встановлення часу створення та оновлення**

#### **Оновлення моделі `Booking`**

Мета: автоматично заповнювати поля `created_at` та `updated_at`.

```python
# models/booking.py
from sqlalchemy import Column, Integer, ForeignKey, DateTime, event
from sqlalchemy.orm import relationship
from datetime import datetime
from app.database import Base

class Booking(Base):
    __tablename__ = 'bookings'

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    resource_id = Column(Integer, ForeignKey("resources.id"), nullable=False)
    start_time = Column(DateTime, nullable=False)
    end_time = Column(DateTime, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    user = relationship("User", back_populates="bookings")
    resource = relationship("Resource", back_populates="bookings")

# Колбек для встановлення `updated_at`
@event.listens_for(Booking, "before_update")
def update_timestamp(mapper, connection, target):
    target.updated_at = datetime.utcnow()
```

- **Поле `updated_at`** автоматично оновлюється при кожному оновленні запису завдяки `onupdate=datetime.utcnow`.
- **Колбек `before_update`** викликається до виконання SQL-запиту для ручного оновлення часу.

---

### **2. Колбек для перевірки даних перед збереженням**

Мета: Перевіряти, чи час початку бронювання менший за час завершення.

```python
@event.listens_for(Booking, "before_insert")
def validate_booking_times(mapper, connection, target):
    if target.start_time >= target.end_time:
        raise ValueError("Start time must be before end time")
```

- **Подія `before_insert`** виконується перед створенням нового запису.
- Якщо перевірка не проходить, піднімається виняток `ValueError`.

---

### **3. Колбек для ведення журналу змін**

Мета: Записувати інформацію про зміни в окрему таблицю журналу.

#### **Модель для журналу:**

```python
# models/log.py
from sqlalchemy import Column, Integer, String, DateTime
from datetime import datetime
from app.database import Base

class ChangeLog(Base):
    __tablename__ = 'change_logs'

    id = Column(Integer, primary_key=True, index=True)
    table_name = Column(String, nullable=False)
    operation = Column(String, nullable=False)  # insert, update, delete
    timestamp = Column(DateTime, default=datetime.utcnow)
    details = Column(String, nullable=True)
```

#### **Колбек для запису змін у таблицю `Booking`:**

```python
@event.listens_for(Booking, "after_insert")
def log_booking_insert(mapper, connection, target):
    connection.execute(
        """
        INSERT INTO change_logs (table_name, operation, timestamp, details)
        VALUES (:table_name, :operation, :timestamp, :details)
        """,
        {
            "table_name": "bookings",
            "operation": "insert",
            "timestamp": datetime.utcnow(),
            "details": f"Booking created with ID {target.id}",
        }
    )

@event.listens_for(Booking, "after_update")
def log_booking_update(mapper, connection, target):
    connection.execute(
        """
        INSERT INTO change_logs (table_name, operation, timestamp, details)
        VALUES (:table_name, :operation, :timestamp, :details)
        """,
        {
            "table_name": "bookings",
            "operation": "update",
            "timestamp": datetime.utcnow(),
            "details": f"Booking with ID {target.id} was updated",
        }
    )

@event.listens_for(Booking, "after_delete")
def log_booking_delete(mapper, connection, target):
    connection.execute(
        """
        INSERT INTO change_logs (table_name, operation, timestamp, details)
        VALUES (:table_name, :operation, :timestamp, :details)
        """,
        {
            "table_name": "bookings",
            "operation": "delete",
            "timestamp": datetime.utcnow(),
            "details": f"Booking with ID {target.id} was deleted",
        }
    )
```

- **Події `after_insert`, `after_update`, `after_delete`**:
    - Використовуються для запису змін у таблицю `change_logs`.
- **`connection.execute`** дозволяє виконати SQL-запит безпосередньо.

---

### **4. Реєстрація глобальних колбеків**

Якщо потрібно використовувати колбеки для всіх моделей:

```python
from sqlalchemy.event import listen

def log_all_changes(mapper, connection, target):
    print(f"Change detected in table {target.__tablename__}")

# Реєстрація глобального колбека
listen(Base, "after_update", log_all_changes)
```
